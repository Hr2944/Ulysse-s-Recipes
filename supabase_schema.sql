-- Schéma SQL pour le projet de recettes de cuisine

-- 1. Table des profils utilisateurs (auteurs)
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT NOT NULL UNIQUE
);
-- Policy: Les utilisateurs peuvent voir tous les profils, mais ne peuvent modifier que le leur.
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- 2. Table des catégories
CREATE TABLE public.categories (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE
);
-- Policy: Lecture publique
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Categories are viewable by everyone." ON public.categories FOR SELECT USING (true);
-- Note: L'ajout de catégories se fera manuellement ou par un admin.

-- 3. Table des tags
CREATE TABLE public.tags (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE
);
-- Policy: Lecture publique
ALTER TABLE public.tags ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Tags are viewable by everyone." ON public.tags FOR SELECT USING (true);

-- 4. Table des ingrédients
CREATE TABLE public.ingredients (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  unit TEXT
);
-- Policy: Lecture publique
ALTER TABLE public.ingredients ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Ingredients are viewable by everyone." ON public.ingredients FOR SELECT USING (true);

-- 5. Table des recettes
CREATE TABLE public.recipes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  title TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  author_id UUID NOT NULL REFERENCES public.profiles(id),
  preamble TEXT,
  prep_time INT NOT NULL, -- in minutes
  cook_time INT NOT NULL, -- in minutes
  difficulty TEXT NOT NULL,
  cost TEXT NOT NULL,
  servings INT NOT NULL,
  image_url TEXT
);
-- Policy: Lecture publique, écriture réservée aux auteurs.
ALTER TABLE public.recipes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Recipes are viewable by everyone." ON public.recipes FOR SELECT USING (true);
CREATE POLICY "Users can insert their own recipes." ON public.recipes FOR INSERT WITH CHECK (auth.uid() = author_id);
CREATE POLICY "Users can update their own recipes." ON public.recipes FOR UPDATE USING (auth.uid() = author_id);
CREATE POLICY "Users can delete their own recipes." ON public.recipes FOR DELETE USING (auth.uid() = author_id);

-- 6. Table des étapes de recette
CREATE TABLE public.steps (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  recipe_id BIGINT NOT NULL REFERENCES public.recipes(id) ON DELETE CASCADE,
  step_number INT NOT NULL,
  description TEXT NOT NULL
);
-- Policy: Lecture publique, écriture liée à la recette.
ALTER TABLE public.steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Steps are viewable by everyone." ON public.steps FOR SELECT USING (true);
CREATE POLICY "Users can insert steps for their own recipes." ON public.steps FOR INSERT WITH CHECK (
  auth.uid() = (SELECT author_id FROM public.recipes WHERE id = recipe_id)
);
CREATE POLICY "Users can update steps for their own recipes." ON public.steps FOR UPDATE USING (
  auth.uid() = (SELECT author_id FROM public.recipes WHERE id = recipe_id)
);
CREATE POLICY "Users can delete steps for their own recipes." ON public.steps FOR DELETE USING (
  auth.uid() = (SELECT author_id FROM public.recipes WHERE id = recipe_id)
);


-- 7. Tables de liaison (Many-to-Many)
CREATE TABLE public.recipe_categories (
  recipe_id BIGINT NOT NULL REFERENCES public.recipes(id) ON DELETE CASCADE,
  category_id BIGINT NOT NULL REFERENCES public.categories(id) ON DELETE CASCADE,
  PRIMARY KEY (recipe_id, category_id)
);
ALTER TABLE public.recipe_categories ENABLE ROW LEVEL SECURITY;
-- Policies similaires à `steps`

CREATE TABLE public.recipe_tags (
  recipe_id BIGINT NOT NULL REFERENCES public.recipes(id) ON DELETE CASCADE,
  tag_id BIGINT NOT NULL REFERENCES public.tags(id) ON DELETE CASCADE,
  PRIMARY KEY (recipe_id, tag_id)
);
ALTER TABLE public.recipe_tags ENABLE ROW LEVEL SECURITY;
-- Policies similaires à `steps`

CREATE TABLE public.recipe_ingredients (
  recipe_id BIGINT NOT NULL REFERENCES public.recipes(id) ON DELETE CASCADE,
  ingredient_id BIGINT NOT NULL REFERENCES public.ingredients(id) ON DELETE CASCADE,
  quantity NUMERIC NOT NULL,
  PRIMARY KEY (recipe_id, ingredient_id)
);
ALTER TABLE public.recipe_ingredients ENABLE ROW LEVEL SECURITY;
-- Policies similaires à `steps`

-- 8. Table des notes
CREATE TABLE public.ratings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  recipe_id BIGINT NOT NULL REFERENCES public.recipes(id) ON DELETE CASCADE,
  value INT NOT NULL CHECK (value >= 1 AND value <= 5),
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);
-- Policy: Lecture publique, écriture ouverte à tous.
ALTER TABLE public.ratings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Ratings are viewable by everyone." ON public.ratings FOR SELECT USING (true);
CREATE POLICY "Anyone can insert a rating." ON public.ratings FOR INSERT WITH CHECK (true);

-- 9. Fonction pour calculer la note moyenne
CREATE OR REPLACE FUNCTION get_average_rating(recipe_id_param BIGINT)
RETURNS FLOAT AS $
  SELECT AVG(value) FROM public.ratings WHERE recipe_id = recipe_id_param;
$ LANGUAGE sql STABLE;

-- 10. Fonction pour créer une recette complète (transactionnelle)
CREATE OR REPLACE FUNCTION create_full_recipe(recipe_data jsonb)
RETURNS bigint AS $
DECLARE
    new_recipe_id bigint;
    step jsonb;
    ingredient_data jsonb;
    ing_id bigint;
    cat_id bigint;
    tag_id bigint;
BEGIN
    -- Insérer la recette principale
    INSERT INTO public.recipes (title, slug, author_id, preamble, prep_time, cook_time, difficulty, cost, servings, image_url)
    VALUES (
        recipe_data->>'title',
        recipe_data->>'slug',
        (recipe_data->>'author_id')::uuid,
        recipe_data->>'preamble',
        (recipe_data->>'prep_time')::int,
        (recipe_data->>'cook_time')::int,
        recipe_data->>'difficulty',
        recipe_data->>'cost',
        (recipe_data->>'servings')::int,
        recipe_data->>'image_url'
    ) RETURNING id INTO new_recipe_id;

    -- Insérer les étapes
    FOR step IN SELECT * FROM jsonb_array_elements(recipe_data->'steps')
    LOOP
        INSERT INTO public.steps (recipe_id, step_number, description)
        VALUES (new_recipe_id, (step->>'step_number')::int, step->>'description');
    END LOOP;

    -- Insérer les ingrédients
    FOR ingredient_data IN SELECT * FROM jsonb_array_elements(recipe_data->'ingredients')
    LOOP
        INSERT INTO public.ingredients (name, unit) 
        VALUES (ingredient_data->>'name', ingredient_data->>'unit')
        ON CONFLICT (name) DO UPDATE SET unit = COALESCE(ingredient_data->>'unit', ingredients.unit)
        RETURNING id INTO ing_id;

        INSERT INTO public.recipe_ingredients (recipe_id, ingredient_id, quantity)
        VALUES (new_recipe_id, ing_id, (ingredient_data->>'quantity')::numeric);
    END LOOP;

    -- Lier les catégories
    FOR cat_id IN SELECT value::bigint FROM jsonb_array_elements_text(recipe_data->'category_ids')
    LOOP
        INSERT INTO public.recipe_categories (recipe_id, category_id) VALUES (new_recipe_id, cat_id);
    END LOOP;

    -- Lier les tags
    FOR tag_id IN SELECT value::bigint FROM jsonb_array_elements_text(recipe_data->'tag_ids')
    LOOP
        INSERT INTO public.recipe_tags (recipe_id, tag_id) VALUES (new_recipe_id, tag_id);
    END LOOP;

    RETURN new_recipe_id;
END;
$ LANGUAGE plpgsql;


-- Données initiales (optionnel, mais recommandé)
INSERT INTO public.categories (name) VALUES ('Entrée'), ('Plat'), ('Dessert'), ('Boisson'), ('Pâtisserie');
INSERT INTO public.tags (name) VALUES ('Végétarien'), ('Végan'), ('Sans gluten'), ('Sans lactose');

-- 12. Policies pour le Stockage (Storage)
-- On assume un bucket public nommé "recipe-images"
CREATE POLICY "Les images sont publiquement accessibles" ON storage.objects
  FOR SELECT USING ( bucket_id = 'recipe-images' );

CREATE POLICY "Les utilisateurs connectés peuvent uploader des images" ON storage.objects
  FOR INSERT WITH CHECK ( bucket_id = 'recipe-images' AND auth.role() = 'authenticated' );

CREATE POLICY "Les utilisateurs peuvent modifier leurs propres images" ON storage.objects
  FOR UPDATE USING ( auth.uid() = owner ) WITH CHECK ( bucket_id = 'recipe-images' );

CREATE POLICY "Les utilisateurs peuvent supprimer leurs propres images" ON storage.objects
  FOR DELETE USING ( auth.uid() = owner );
